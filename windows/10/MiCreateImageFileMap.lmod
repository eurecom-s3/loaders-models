LOADREL ntkrnlmp

DEFINE FILESIZE 500

INPUT HEADER FILESIZE

#### Handy constant
P: zero <- INT 0 4

#### Alias for DosHeader
P: dosHdr <- HEADER as DOSHeader
#### NT Headers

P: ntHdr <- HEADER[dosHdr.e_lfanew, sizeof _IMAGE_NT_HEADERS] as _IMAGE_NT_HEADERS

#### Program Header
P: progHdr <- ntHdr.FileHeader as _IMAGE_FILE_HEADER

#### Optional Header
P: optHdr <- ntHdr.OptionalHeader as _IMAGE_OPTIONAL_HEADER

### Only useful for verification. Check that exe is smaller than 4GB
V1: ULE INT FILESIZE 8 0xffffffff term

P: fileSizePages <- SHR ADD (INT FILESIZE 4) 0xfff 12

# line 208
V2: AND EQ dosHdr.magic[0] "M" EQ dosHdr.magic[1] "Z" term

# line 216
V3: NOT OVFLADD dosHdr.e_lfanew 0xf8 term

# line 224
V4: ULT ADD dosHdr.e_lfanew 0xf8 FILESIZE term

# line 231
V5: UGT (ADD dosHdr.e_lfanew 0xf8) (SHL fileSizePages 12)

# line 261
V6(V5): ULT (ADD dosHdr.e_lfanew 0xf8) 0x1000 term


# line 289 -> call MiVerifyImageHeader
######## MiVerifyImageHeader
# line 19
V7: EQ ntHdr.Signature 0x4550 term

# line 22
V8: OR (NEQ progHdr.Machine 0) (NEQ progHdr.SizeOfOptionalHeader 0) term

# line 28
V9: EQ BITAND progHdr.Characteristics 2 2 term

# line 30
V10: EQ BITAND dosHdr.e_lfanew 3 0 term

# line 103
V11: EQ optHdr.Magic 0x10b term

# line 106
V12: OR (EQ BITAND optHdr.FileAlignment 0x1ff 0) (EQ optHdr.FileAlignment optHdr.SectionAlignment) term

# line 111
V13: NEQ optHdr.FileAlignment 0 term

# line 117
V14: ISPOW2 optHdr.SectionAlignment term

# line 122
V15: ISPOW2 optHdr.FileAlignment term

# line 127
V16: UGE optHdr.SectionAlignment optHdr.FileAlignment term

# line 133
V17: ULE optHdr.SizeOfImage 0x77000000 term

# line 139
V18: OR (EQ progHdr.Machine 0x14c) (EQ progHdr.Machine 0x1c4) term

# line 144
V19: ULT optHdr.SizeOfHeaders optHdr.SizeOfImage term

# line 149
V20: EQ optHdr.ImageBase[0, 2] 0 term

# line 154
V21: AND (NEQ progHdr.Machine 0x14C) (NEQ progHdr.Machine 0x8664)

# line 156
V22(V21): NEq BITAND progHdr.Machine 1 1 term

# line 161
V23(V21): EQ BITAND optHdr.DllCharacteristics 0x140 0x140 term

V24(!V21): AND (EQ BITAND progHdr.Machine 1 0) (EQ BITAND optHdr.DllCharacteristics 0x1000 1) term
######### End of MiVerifyImageHeader

# line 290
V25: NEQ (ADD (SHR optHdr.SizeOfImage 12) (BITAND optHdr.SizeOfImage 0xfff)) 0 term

# line 297 - 301
P: sizeNtHdr <- ADD progHdr.SizeOfOptionalHeader 24
P: sizeSectTable <- MUL progHdr.NumberOfSections 40
P: offEndHdrs <- ADD ADD sizeNtHdr sizeSectTable dosHdr.e_lfanew

# line 302
V26: UGT offEndHdrs dosHdr.e_lfanew term

# line 316
P: pageOffsetEndNtHdr <- BITAND (ADD dosHdr.e_lfanew sizeNtHdr) 0xfff

# line 318
P: pageOffsetEndSectTable <- ADD pageOffsetEndNtHdr sizeSectTable

# line 317 (first operand of the OR at line 320)
V27: NEq pageOffsetEndSectTable 0 term
V28: UGT (BITAND (ADD pageOffsetEndSectTable 0xfff) 0xFFFFF000) pageOffsetEndSectTable term

# line 342 (MiReadImageHeaders needs the starting address to be lower than FILESIZE). The bitand mask is to model ((x >> 12) << 12)
V29: ULT BITAND (ADD sizeNtHdr dosHdr.e_lfanew) 0xfffff000 FILESIZE term
# line 345 (cheks that the file is read at least up until the end of the section table, which means that this must be within the file ...)
V30: ULE pageOffsetEndSectTable FILESIZE term
# ... and within one page from the starting address
V31: ULT pageOffsetEndSectTable (ADD (BITAND (ADD sizeNtHdr dosHdr.e_lfanew) 0xfffff000) 0x1000) term


# line 357
V32: ULT optHdr.SectionAlignment 0x1000
# line 366... only x86 and x86_64 supported for sectionalign < 0x1000
V33(V32): OR (EQ progHdr.Machine 0x14C) (EQ progHdr.Machine 0x8664) term

#### MiBuildImageControlArea
# line 45
P: nPagesImage <- SHR optHdr.SizeOfImage 12
V34: NEq BITAND optHdr.SizeOfImage 0xFFF 0
P(V34): nPagesImage <- ADD (SHR optHdr.SizeOfImage 12) 1
V35: NEq nPagesImage 0 term

P: stuff <- ADD optHdr.SizeOfHeaders SUB optHdr.SectionAlignment 1
P: nPagesHeaders <- ADD (SHR (ADD (BITAND (BITAND stuff (BITNOT SUB optHdr.SectionAlignment 1)) 0xFFF) 0xFFF) 12) (BITAND (SHR (BITNOT SUB optHdr.SectionAlignment 1) 12) (SHR stuff 12))

# line 174
V36(V32): UGT stuff optHdr.SizeOfHeaders term
V37(V32): ULE nPagesHeaders nPagesImage term

#### MiParseImageSectionHeaders
P: offSectTable <- ADD sizeNtHdr dosHdr.e_lfanew
P: nSect <- progHdr.NumberOfSections

# line 110
V38(!V32): NEq nSect 0 term

# Calculated before calling the function (line 188 of MiCreateControlArea)
P(!V32): remainingPages <- SUB nPagesImage nPagesHeaders

# line 99
P(!V32): startOfNextSect <- ADD optHdr.ImageBase (SHL nPagesHeaders 12)

G1: ULE nSect 5 term
L1: section <- LOOP(HEADER, offSectTable, 40, nSect, 5) AS _IMAGE_SECTION_HEADER
  # Common to both branch of the SectionAlingment < 0x1000
  # lines 73 & 127
  P: sectSize <- section.VirtualSize
  V38: EQ section.VirtualSize 0
  P(V38): sectSize <- section.SizeOfRawData

  # line 80
  V39(V32): NOT OVFLADD section.SizeOfRawData section.PointerToRawData term
  V40(V32): AND (EQ section.PointerToRawData section.VirtualAddress) (ULE sectSize section.SizeOfRawData)

  # line 131
  P: parsedPtrRawData <- section.PointerToRawData
  V41(!V32): EQ section.SizeOfRawData 0 term
  P(V41): parsedPtrRawData <- INT 0 4

  # line 140
  V42(!V32): UGE ADD parsedPtrRawData section.SizeOfRawData parsedPtrRawData term

  # line 145
  V43(!V32): NEq sectSize 0 term

  P: VA <- ADD optHdr.ImageBase section.VirtualAddress
  V44(!V32): EQ VA startOfNextSect term

  V45(!V32): UGT (ADD sectSize SUB optHdr.SectionAlignment 1) sectSize term

  P(!V32): nPagesSect <- SHR ALIGNUP sectSize optHdr.SectionAlignment 12
  V46(!V32): ULE nPagesSect remainingPages term

  P(!V32): remainingPages <- SUB remainingPages nPagesSect

  # line 185
  P: endRawData <- ADD section.SizeOfRawData section.PointerToRawData
  V47(!V32): UGT ALIGNUP endRawData optHdr.FileAlignment section.PointerToRawData term

END L1

# line 115
V48(!V32): ULT remainingPages (SHR optHdr.SectionAlignment 12) term

# line 110 (reached the second time after the loop, coming from line 282)
V49(!V32): ULE endRawData FILESIZE term
