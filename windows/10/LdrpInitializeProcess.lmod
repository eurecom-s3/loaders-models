LOADREL ntkrnlmp

DEFINE FILESIZE 500
INPUT HEADER FILESIZE as DOSHeader

P: zero <- INT 0 4
P: one <- INT 1 4

P: NT_HEADER <- HEADER[HEADER.e_lfanew, sizeof _IMAGE_NT_HEADERS] as _IMAGE_NT_HEADERS
P: fileHdr <- NT_HEADER.FileHeader as _IMAGE_FILE_HEADER
P: optHdr <- NT_HEADER.OptionalHeader as _IMAGE_OPTIONAL_HEADER
P: nSections <- fileHdr.NumberOfSections
P: sectionTableOffset <- ADD HEADER.e_lfanew (ADD fileHdr.SizeOfOptionalHeader 24)
P: imageEnd <- ADD optHdr.ImageBase optHdr.SizeOfImage

#### LdrpValidateEntrySection
V1: OR (Eq optHdr.AddressOfEntryPoint 0) (UGE optHdr.AddressOfEntryPoint optHdr.SizeOfHeaders) term

## Needs relocation?
# V2: UGE optHdr.ImageBase 0x80000000
V2: UGE optHdr.ImageBase 0x80000000

G1: ULE nSections 5 term
G99: NEq nSections 0 term
L1(V2): section <- LOOP(HEADER, sectionTableOffset, 40, nSections, 5) AS _IMAGE_SECTION_HEADER
    P: size <- section.SizeOfRawData
    P: VA <- section.VirtualAddress
    P: endSect <- ADD VA (ALIGNUP size optHdr.SectionAlignment)
    P: charact <- section.Characteristics
    V3: AND (OR (ULT VA optHdr.ImageBase) (UGT endSect imageEnd)) (NEq size 0)
    V4(V3): EQ (BITAND charact[3] 0x80) 0x80 term
END L1

### Relocations
#### They come into play only if the image needs to be relocated.
#### This means that the ImageBase is either 0 or in the range of other DLLs

P: relocDir <- optHdr.DataDirectory[40, 8] as _IMAGE_DATA_DIRECTORY
P: relocVA <- relocDir.VirtualAddress
P: relocSize <- relocDir.Size

#### LdrRelocateImageWithBias:45,48
V6(V2): AND (UGE optHdr.NumberOfRvaAndSizes 5) AND (NEq relocVA 0) (NEq relocSize 0)
#V6(V2): AND (UGE optHdr.NumberOfRvaAndSizes 5) AND (NEq relocVA 0) (NEq relocSize 0) term
G7(V6): ULT relocSize 0x100 term

### If the image is relocated, but doesn't have the reloc table, check that it wasn't stripped away, in which case the image is invalid
#### LdrRelocateImageWithBias:46,49
V7(V2, !V6): EQ BITAND fileHdr.Characteristics 1 1 term

P: tmpSize <- relocSize
P(V6): loopStart <- relocVA
L2(V6): relocBlockAddr <- VLOOP(loopStart, nextBlockAddr, V99, 1)
    P: relocBlock <- HEADER[relocBlockAddr, 8]
    P: blockSize <- relocBlock[4, 3]
    P: blockPage <- relocBlock[0, 3]
    G6: ULT blockPage 2 term
    P: firstEntryAddr <- ADD relocBlockAddr 8
    P: nEntry <- SHR (SUB blockSize 8) 2
    P: tmpSize <- SUB tmpSize blockSize
    P: nextBlockAddr <- ADD relocBlockAddr blockSize
    V99: UGT tmpSize 0

    P: tmpEntry <- INT 0 4
    L3: entryAddr <- VLOOP(firstEntryAddr, nextBAddr, V98, 1)
        P: entry <- HEADER[entryAddr, 2]
        P: tmpEntry <- ADD tmpEntry 1
        P: nextBAddr <- ADD entryAddr 2

        P: relocType <- BITAND entry[0] 0xf
        P: relocAddr <- SHR (BITAND entry 0xfff0) 4

	V11: EQ (BITAND (SHL one (SHR entry 12)) 0x3a0) 0 term
        V12: OR EQ relocType 10 ULE relocType 4 term
        V13: ULT ADD blockPage relocAddr imageEnd term
	G13: ULT ADD blockPage relocAddr FILESIZE term
        ## RelocType 4 uses two entries instead of 1
        V14: Eq relocType 4
        P(V14): tmpEntry <- ADD tmpEntry 1
        P(V14): nextBAddr <- ADD nextBAddr 2

        V98: ULE tmpEntry nEntry
    END L3
END L2
G4: EQ tmpSize 0 term

### LdrpCheckForSecuROMImage
#### Other implicit constraints, like the one above
P: debugDir <- optHdr.DataDirectory[48, 8] as _IMAGE_DATA_DIRECTORY
P: debugVA  <- debugDir.VirtualAddress
P: debugSize <- debugDir.Size
P: nDebugEntry <- DIV debugSize 28
V15: NEq debugSize 0
G2: ULE nDebugEntry 5 term
L4: debugEntry <- LOOP(HEADER, debugVA, 0x1c, nDebugEntry, 5) as _IMAGE_DEBUG_DIRECTORY
    P: dbgEntrySize <- debugEntry.SizeOfData
    P: dbgPtrData <- debugEntry.PointerToRawData
    V16: ULT (ADD dbgEntrySize dbgPtrData) FILESIZE term
END L4

#### LdrpCheckForSecuROMImage also checks that the certificate entry lies within the file. We do not support it for generation (it would need to create a valida certificate (which is impossible ofc)
P: certDir <- optHdr.DataDirectory[32, 8] as _IMAGE_DATA_DIRECTORY
P: certDirVA <- certDir.VirtualAddress
P: certDirSize <- certDir.Size
G3: EQ certDir 0 term
V17: ULT (ADD certDirSize certDirVA) FILESIZE term

### LdrpCheckForSafeDiscImage
#### Implicit constraints due to dereferencing fields in the headers
V18: UGT SUB optHdr.SizeOfHeaders 0x2c 0 term
V19: ULT ADD optHdr.SizeOfHeaders 0x13 FILESIZE term

### LdrpInitializeTls
#### If the directory is defined it must lay inside the image
P: tlsDir <- optHdr.DataDirectory[72, 8] as _IMAGE_DATA_DIRECTORY
P: tlsDirEnd <- ADD tlsDir.VirtualAddress tlsDir.Size
V20: AND (UGT optHdr.NumberOfRvaAndSizes 9) (NEq tlsDir.VirtualAddress 0)
V21(V20): UGT (SUB 0xffffffff tlsDir.VirtualAddress) tlsDir.Size term
V22(V20): ULE tlsDirEnd imageEnd term
G5: OR (ULE optHdr.NumberOfRvaAndSizes 9) (Eq tlsDir 0) term
